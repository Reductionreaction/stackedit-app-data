# 概述

[toc]

CPU工作模式不同，工作能力与指令集有关

全部指令与特权指令（in,out,mov），kelnel mode核心态模式，user mode时要排除特权指令

-   发生异常中断进程，例如在普通用户程序中出现特权指令，cpu状态会发生翻转，切换到k-mode，查询中断向量表(异常对应的处理代码)，处理错误

操作系统是程序，提供硬件与用户的媒介，提供环境，以便利有效的方式运行程

-   扩展机器-抽象与模拟 -> 将每个程序运行在一个虚拟机中，有自己的设备，储存器

-   资源管理-保护与复用 -> 时分，空分复用

终端设备：显示器+键盘

| cpu |  |
|--|--|
| io | ram |

jmp, mov, call访问地址的命令都有可能发生异常：地址越界 || 地址不在主存中(缺页)
**并发**的设计最初是为了不同的计算任务在同一个设备上运行(提高硬件资源的利用率), 同一个任务的分解虽然加快了任务的速度, 但是需要提供同步机制(任务执行的速度不同会发生错误)

程序的推进速度受到外围设备的影响，异步性在非并发进程中没有影响

**操作系统的主要特征**
- 并发性
	- 提高资源的利用率
- 共享性
	- 时分复用 $\rightarrow$ 互斥访问
	- 同时访问：磁盘，主存 $\rightarrow$ 空间复用
- 异步性
	- 任务执行时间, 推进速度不同, 中断的发生, 事件发生不可预测
	- 能处理随机发生的事件
- 虚拟性
	- 应用程序使用时在虚拟机上运行,$\rightarrow$ 将一个设备虚拟成多个
	- $0 \rightarrow2^{32}-1$ 或 $0\rightarrow2^{64}-1$ 位地址都可以使用, 将主存和磁盘的一部分虚拟成一个主存, $\rightarrow$将多个设备虚拟成一个
	- 假脱机: 一个io设备虚拟成多个
	
# os运行机制

**计算机引导过程**
bios(可以访问io设备, 检测硬件) $\rightarrow$ 读取磁盘驱动0号扇区(55 aa?) $\rightarrow$ 跳转到对应地址MBR(硬件厂商确定格式) $\rightarrow$(这里还有一步跳转到grub或者lilo) 加载kernel到主存(0号进程,填中断向量表) $\rightarrow$ init进程(1号进程), 读取配置文件, 启动服务
idle 0 : 填满cpu使用时间
**os是中断驱动的**
- io设备通知cpu(有int引脚或控制芯片(可以并联)$\rightarrow$接受io设备的电信号, 发生变化后读取中断寄存器 $\rightarrow$硬件提供机制,查中断向量表(一组地址,硬件定义长度),执行对应地址上的代码)  **现代可以直接通知os**
- 初始化os时会初始化一个定时器: 每隔一段时间产生一个中断
- 中断过程中还可以调度其他程序
- 应用程序中发生异常(内中断) vs 外围设备通知中断(外中断)
- ```syscal``` 引发中断 : 与外部中断类似 ``` mov jmp /0```
![os是中断驱动的](/imgs/2024-03-06/2MBzTgXTdiu7dkpU.png)

- 保护模式：cpu可以运行在两种状态中$\rightarrow$ 核心态与用户态，早期是实模式，不区分核心态与用户态
- CR0, CR1, CR2属于控制寄存器，可以切换工作状态
- 用户态需要接受输入输出需要通过中断呼唤操作系统
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyMDg1NTYxMjEsMTcyMjE2NzU4LC0xNz
I1MTAyNjMwLC0xNzI1MTAyNjMwLDg1NjkzOTM1OCwxMjAzMDE4
OTU4LDE1MzA3NDc2NTEsLTcyMjgyODY4OCwxNDY0ODQ4MjY5LC
0xMjU4NDg5ODg4LDE5ODI5NjM5MzgsNDgxMDAxMjkyLC0xMDkz
MDMxNjcxLC0yMDI2MTE0NjIyLDQxNzk1NDc4MywxMzc0MDgxMz
AyLDE4NzY2MzMyMDAsNjQzNjAyOTIyLC0xODc0NzIwNzYyXX0=

-->