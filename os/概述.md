# 概述

[toc]

CPU工作模式不同，工作能力与指令集有关

全部指令与特权指令（in,out,mov），kelnel mode核心态模式，user mode时要排除特权指令

-   发生异常中断进程，例如在普通用户程序中出现特权指令，cpu状态会发生翻转，切换到k-mode，查询中断向量表(异常对应的处理代码)，处理错误

操作系统是程序，提供硬件与用户的媒介，提供环境，以便利有效的方式运行程

-   扩展机器-抽象与模拟 -> 将每个程序运行在一个虚拟机中，有自己的设备，储存器

-   资源管理-保护与复用 -> 时分，空分复用

终端设备：显示器+键盘

| cpu |  |
|--|--|
| io | ram |

jmp, mov, call访问地址的命令都有可能发生异常：地址越界 || 地址不在主存中(缺页)
**并发**的设计最初是为了不同的计算任务在同一个设备上运行(提高硬件资源的利用率), 同一个任务的分解虽然加快了任务的速度, 但是需要提供同步机制(任务执行的速度不同会发生错误)

程序的推进速度受到外围设备的影响，异步性在非并发进程中没有影响

**操作系统的主要特征**
- 并发性
	- 提高资源的利用率
- 共享性
	- 时分复用 $\rightarrow$ 互斥访问
	- 同时访问：磁盘，主存 $\rightarrow$ 空间复用
- 异步性
	- 任务执行时间, 推进速度不同, 中断的发生, 事件发生不可预测
	- 能处理随机发生的事件
- 虚拟性
	- 应用程序使用时在虚拟机上运行,$\rightarrow$ 将一个设备虚拟成多个
	- $0\~2^32-1$ 或 $0\~2^64-1$ 位地址都可以使用, 将主存和磁盘的一部分虚拟成一个主存, $\rightarrow$将多个设备虚拟成一个
	- 假脱机: 一个io设备虚拟成多个
	
## os运行机制

**计算机引导过程**
bios(可以访问io设备, 检测硬件) $\rightarrow$ 读取磁盘驱动0号扇区(55 aa?) $\rightarrow$ 跳转到对应地址MBR(硬件厂商确定格式) $\rightarrow$(这里还有一步跳转到grub或者lilo) 加载kernel到主存(0号进程) $\rightarrow$ init进程(1号进程), 读取配置文件, 启动服务
idle 0 填满cpu使用时间
os是中断驱动的
- io设备通知cpu(有int引脚, 控制芯片,可以并联$\rightarrow$接受io设备的电信号, 发生变化后读取中断寄存器$\right arrow$硬件提供机制,用中断向量表)

<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA0NzU4NzkwMSwxMjAzMDE4OTU4LDE1Mz
A3NDc2NTEsLTcyMjgyODY4OCwxNDY0ODQ4MjY5LC0xMjU4NDg5
ODg4LDE5ODI5NjM5MzgsNDgxMDAxMjkyLC0xMDkzMDMxNjcxLC
0yMDI2MTE0NjIyLDQxNzk1NDc4MywxMzc0MDgxMzAyLDE4NzY2
MzMyMDAsNjQzNjAyOTIyLC0xODc0NzIwNzYyXX0=
-->