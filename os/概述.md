# 概述

[toc]

CPU工作模式不同，工作能力与指令集有关

全部指令与特权指令（in,out,mov），kelnel mode核心态模式，user mode时要排除特权指令

-   发生异常中断进程，例如在普通用户程序中出现特权指令，cpu状态会发生翻转，切换到k-mode，查询中断向量表(异常对应的处理代码)，处理错误

操作系统是程序，提供硬件与用户的媒介，提供环境，以便利有效的方式运行程

-   扩展机器-抽象与模拟 -> 将每个程序运行在一个虚拟机中，有自己的设备，储存器

-   资源管理-保护与复用 -> 时分，空分复用

终端设备：显示器+键盘

| cpu |  |
|--|--|
| io | ram |

jmp, mov, call访问地址的命令都有可能发生异常：地址越界 || 地址不在主存中(缺页)
**并发**的设计最初是为了不同的计算任务在同一个设备上运行(提高硬件资源的利用率), 同一个任务的分解虽然加快了任务的速度, 但是需要提供同步机制(任务执行的速度不同会发生错误)

程序的推进速度受到外围设备的影响，异步性在非并发进程中没有影响

**操作系统的主要特征**
- 并发性
	- 提高资源的利用率
- 共享性
	- 时分复用 $\rightarrow$ 互斥访问
	- 同时访问：磁盘，主存 $\rightarrow$ 空间复用
- 异步性
	- 任务执行时间, 推进速度不同, 中断的发生, 事件发生不可预测
	- 能处理随机发生的事件
- 虚拟性
	- 应用程序使用时在虚拟机上运行,$\rightarrow$ 将一个设备虚拟成多个
	- $0 \rightarrow2^{32}-1$ 或 $0\rightarrow2^{64}-1$ 位地址都可以使用, 将主存和磁盘的一部分虚拟成一个主存, $\rightarrow$将多个设备虚拟成一个
	- 假脱机: 一个io设备虚拟成多个
	
# os运行机制

**计算机引导过程**
bios(可以访问io设备, 检测硬件) $\rightarrow$ 读取磁盘驱动0号扇区(55 aa?) $\rightarrow$ 跳转到对应地址MBR(硬件厂商确定格式) $\rightarrow$(这里还有一步跳转到grub或者lilo) 加载kernel到主存(0号进程,填中断向量表) $\rightarrow$ init进程(1号进程), 读取配置文件, 启动服务
idle 0 : 填满cpu使用时间
**os是中断驱动的**
- io设备通知cpu(有int引脚或控制芯片(可以并联)$\rightarrow$接受io设备的电信号, 发生变化后读取中断寄存器 $\rightarrow$硬件提供机制,查中断向量表(一组地址,硬件定义长度),执行对应地址上的代码)  **现代可以直接通知os**
- 初始化os时会初始化一个定时器: 每隔一段时间产生一个中断
- 中断过程中还可以调度其他程序
- 应用程序中发生异常(内中断) vs 外围设备通知中断(外中断)
- ```syscal``` 引发中断 : 与外部中断类似 ``` mov jmp /0```
![os是中断驱动的](/imgs/2024-03-06/2MBzTgXTdiu7dkpU.png)

- 保护模式：cpu可以运行在两种状态中$\rightarrow$ 核心态与用户态，早期是实模式，不区分核心态与用户态
- CR0, CR1, CR2属于控制寄存器，可以切换工作状态
- 用户态需要接受输入输出需要通过中断呼唤操作系统
- ```i++ : mov xxxx zax, add zax, mov zax xxxx```
- in/out需要访问外设
- 主存保护机制: 分段, cpu提供寄存器,由操作系统定义应用的起始地址, jmp, mov, call等指令时进行检查, 如果发生溢出, 就产生异常, 唤起操作系统.  地址转换时一并完成
**用户代码的有限直接执行**
---- 用户态A
        ---核心态
              ---用户态B
---  timeline ---
- sp指向栈顶位置
- call: 将下一条指令压入栈中(sp-2, 十六位), 跳转到对应的地址中(把pc赋值为地址), 执行子程序, 遇到ret指令就将pc赋值为sp
![输入图片说明](/imgs/2024-03-13/G1etVygmQsCwAubx.png)
少了中断处理程序, 和应用异常
**中断属于硬件机制, 保存现场信息 , cpu翻转到核心态, 查询中断向量表, os进行运行处理**
- 读入操作: 用out不断读取状态寄存器判断是否空闲, 发送读取命令, 用out对port进行写控制寄存器操作, 继续读状态寄存器, 写入数据寄存器直到free, 用In指令读到cpu中, 再用mov写到主存 $\rightarrow$ 

- 任务a在运行是呼唤os, 如果设备没有准备好，会主动放弃cpu, os会调度执行别的计算任务，任务b进行过程中发生外部中断，即a任务需要的设备空闲，调度io设备，再继续计算b, 还可能发生中断，即输入任务完成
- 非抢占：主动放弃cpu时调度的任务
- 抢占：时间轮片用完

**程序浮动**： 处理内存中的空闲片段
- 分段：将程序划分为不同的模块
- 分页：将主存分成不同的页框，将程序的逻辑空间划分为不同的页面塞进不同的页框中。
**存储保护**：任务互不干扰

```C
write(1,"helloworld\n",13) //0,1,2号文件分别时i/o ,标准错误输出？，unix中所有的程序都是文件，这段代码是shell的子进程，i/o设备已经打开了
```

posix标准: 以元函数的形式定义头文件, 即os必须要实现的功能
操作系统向外提供库函数

- os保护现场时保存通用寄存器信息，这里可以调用pusha, popa
- 恢复现场可能不会跳转到系统调用的源程序，可能会跳转到其他的应用程序
- elf: execute,link,format
```bash
ld hello.o #将应用与库链接在一起
 ```

- 动态链接会写入一个查询的call指令，调用操作系统中提供的查询服务，运行相应的库
- eg：
	- 假设现在有两个程序program1.o和program2.o，这两者共用同一个库lib.o,假设首先运行程序program1，系统首先加载program1.o，当系统发现program1.o中用到了lib.o，即program1.o依赖于lib.o，那么系统接着加载lib.o，如果program1.o和lib.o还依赖于其他目标文件，则依次全部加载到内存中。当program2运行时，同样的加载program2.o，然后发现program2.o依赖于lib.o，但是此时lib.o已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的lib.o映射到program2的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。

[原文链接](https://blog.csdn.net/kang___xi/article/details/80210717)

- intfp: 表的索引号

$H(Q_m) = \sum_k p_{mk} (1 - p_{mk})$

- int 08h int 1ch?
- i386以后才存在核心栈，中断发生时使用、
- i8086没有用户态和核心态的区分，没有实模式和保护模式
- iret使cpu状态发生翻转，回到用户态
int 80h, 提供syscall

- iret 类的指令可以从核心态切换到用户态
- 中断屏蔽，优先级高的有些中断可以屏蔽优先级低的先执行

慢中断和快中断
- 慢中断：处理时不关中断，关中断过久会伤害并发性
- 快中断

![输入图片说明](/imgs/2024-04-10/0VBEA2d9ufEEKIzi.png)

信号机制：由os提供的类似于中断的机制
也含有可屏蔽与不可屏蔽的信号（如 kill -9 -pid）

## 概论小结
- 系统调用和库函数
库函数是属于高级程序语言和应用程序的，有些是对系统调用的进一步抽象，属于用户层面，是系统调用的上层
- 通道是独立与cpu的，控制I/O的设备
- 单CPU上的进程是不能并行的
- 进程结束是需要syscall的，exit0

# 处理器管理
进程实体：程序+数据+PCB（进程控制块）
进程是进程实体运行的过程

![输入图片说明](/imgs/2024-04-17/yc5sCSc9IDizovLN.png)
![输入图片说明](/imgs/2024-05-08/kO8Tt2g0Md0iiriM.png)
![输入图片说明](/imgs/2024-05-08/o5cSzODqHB0ZeDxw.png)

进程空间是独立的，进程运行期间不能访问其他进程的空间
- 管道：注意，**管道只能是单向的**，只能由创建进程写入，并且在读取后立即释放空间
- 信箱
- 直接发送格式化信息
- 共享空间

- fork() 之后子进程是从fork()之后开始执行的
- 从子进程来看的返回值是0, 父进程是pid，小于0表示创建失败

读者，写者问题
读进程只需要第一个进程去争取rw访问权限，归还时由最后一个读进程归还
![输入图片说明](/imgs/2024-05-15/iSeK4VF29myRkCKU.png)
这里的rc是reader_count, wr=1确保写进程只能有一个

![输入图片说明](/imgs/2024-06-07/2QKzfDNP9ZIYsEHk.png)
[彻底弄懂 Linux 下的文件描述符（fd）_linux fd管理-CSDN博客](https://blog.csdn.net/yushuaigee/article/details/107883964)
如果在同一个进程中使用了两次完全相同的open，会获得两个文件描述符，但是它们会指向同一个打开文件表项
在不同进程中使用两次open会创建两个表项，虽然最终会指向同一个inode值，但是这实现了每个进程读写指针独立

# 储存管理

## 分页
分页解决的问题是内存中不可能有很大的连续存储空间的问题，可以将这些内容存在不同的页中，需要时将部分内容调入内存
反置页表：块号，页号，仅保存调入内存的页面
![输入图片说明](/imgs/2024-06-11/gnUrG2MvyB2j41Gn.png)

# 概述
计算机系统包括：程序，用户，硬件，操作系统
操作系统是一个程序，充当用户与硬件的媒介，提供环境能便利有效地运行程序
操作系统两大任务：
自顶而下：扩展机，为开发人员提供简洁易用的资源抽象（抽象：处理器，设备，存储），虚拟机：让每个应用都拥有这些
自底而上：资源管理者，管理种类繁多，纷繁复杂的硬件资源。复用：时分，空分。保护：防止应用程序间干扰
功能和目标：
- 资源管理
- 控制执行
- 提供接口
目标
- 方便用户使用
- 提升机器能力
- 提高了运行效率
- 提供开放环境
主要特征
- 并发，并行比并发严格
- 共享，互斥，同时访问
- 异步，任务推进的时间，推进速度不定
- 虚拟，多道程序设计，窗口技术，假脱机

发展与形成
手工操作阶段：电子继电器-真空管
管理程序阶段：晶体管，批处理方式，单道程序设计
多道程序设计和分时系统，集成电路

中断技术，通道技术为基础技术
解决的主要是：存储保护和程序浮动，处理器管理与分配，系统的管理和调度

批处理操作系统：作业周期长，多道
分时操作系统：允许多个用户同时
实时操作系统：实现定义好的时间限制内处理内部或外部事件

提供服务：
创建，执行程序，数据输入输出，信息存取，通信，错误检测（完成功能）
统计，保护，资源分配（提高效率）

接口
用户接口：shell， x-window
程序接口:api, syscall，posix
![输入图片说明](/imgs/2024-06-11/YRd6mIJrAIaIxQ81.png)
![输入图片说明](/imgs/2024-06-11/TzMwJcP9fIfTc5ip.png)

基本元素：
内核
进程：资源分配和调度的单位
线程：调度的单位(cpu？)

结构发展与分类
整体式：紧密效率高，独立性差，结构不清晰 IBM S/360(UNIX)
层次式：THE 维护方便，通信开销大
虚拟机： IBM VM/370 CMS, 灵活方便
客户服务器及微内核
基本设计原则是策略与机制的分离

![输入图片说明](/imgs/2024-06-11/lNLnYU70eVA0NhHW.png)
![输入图片说明](/imgs/2024-06-11/rzX4c8IT5lbrqp5e.png)
可扩展性，移植性好，但通信开销大，效率低
![输入图片说明](/imgs/2024-06-11/tdYujuN3ZfGG4h3Y.png)
windows是混合内核

# 处理器管理
PSW：程序基本状态（程序计数器，条件码，状态位），中断码，中断屏蔽位
中断时并发的基础
外部中断：I/O中断，时钟中断，硬件故障，可以被屏蔽
内部中断：自愿中断（访管指令--syscall），被迫中断（程序异常），不可屏蔽，不可嵌套（可分为出错和陷入）

中断处理过程：发现中断源，保护现场，转向中断处理程序，恢复现场
![输入图片说明](/imgs/2024-06-14/ESG8VZZeD9hdRkm8.png)
缺页也算程序性中断

多重中断：串行（关中断），嵌套（开中断直接处理），及时处理（程序性处理）

慢中断：保存所有的寄存器，不关中断，执行完之后调度
快中断：只保存内核使用的寄存器，关中断，执行完返回进程
![输入图片说明](/imgs/2024-06-14/duWXPVs3D0RaDDmW.png)
Minx中断处理，缩短屏蔽时间，核心代码在关中断的核心态完成，另一部分耗时的在非核心态完成，组织成了驱动程序，如磁盘，中断，时钟等。

信号机制：模拟硬件中断的通信机制（内核向进程，进程向进程）
![输入图片说明](/imgs/2024-06-14/wqYG0v30Dv3VJ87O.png)

进程：操作系统资源分配和保护的基本单位
共享性，动态性，独立性，制约性，并发性
三态和五态模型：多了新建态和终止态
除了终止态都可以挂起，提高资源利用率，减轻系统负载，调试程序
进程队列：链接，索引

进程只能在核心态切换
![输入图片说明](/imgs/2024-06-15/2fCSEsPx5DpYBhhR.png)
这是啥意思

创建:clone fork 阻塞: wait,waitpid,sleep 终止：exit 根据pid找到pcb归还资源，和pcb

进程上下文（物理实体和环境）包括：用户级上下文（程序，堆栈），寄存器上下文，系统级上下文（PCB，页表，段表）
进程控制块：进程管理，内存管理，文件管理
![输入图片说明](/imgs/2024-06-15/MEw1B7w1HgikZ5oG.png)
线程：处理器调度和分配的基本单位，同一进程中共享
thread_yield 出让
thread_exit 

内核级：需要两次模式切换
用户级：代价小，不能同时在多个cpu上运行，会导致整个阻塞，非抢占式调度。
改进机制：
–upcall机制
–非阻塞系统调用，增加select系统调用
混合型：设计不当可能效果更差
![输入图片说明](/imgs/2024-06-15/hWshUiEosuSEXaKm.png)

低级调度：抢占式（限时，优先级）非抢占

高级作业调度
FCFS：不利于短作业利于长作业
SJF（最短作业优先）：长作业可能饥饿
SRTF(最短剩余时间)：预测运行时间最短的
响应比最高优先算法（HRRF）：相应比=响应时间/作业估计时间

低级作业调度
优先数调度：有抢占和非抢占式，分静态和动态优先数（等待时间越长，优先数越高，占用cpu时间越长，优先数越低）
最短进程优先：老化算法（$a*T_0 + (1-a)*T_1$）
保证调度算法：–在有n运行的用户系统中，每个进程将获得处理器能力的1/n。
实现：
–计算实际获得的CPU时间和应获得的CPU时间之比，调度转向比率最低的进程。
彩票调度算法：对各资源发放彩票，决策时随机选一张彩票，持有彩票的进程获得资源（持有的彩票越多，获得系统资源的机会越大）

实时调度
可调度：能在规定时间内做完
C1/P1 + C2/P2 + … + Cm/Pm <= 1
其中m为事件总数，Ci为某个事件的处理时间，Pi为事件发生的周期
实时调度算法
单比率：优先级与频率成正比（最优）
限期调度：就绪队列按照处理时间截至期限排序
最少裕度：裕度=截至时间-（就绪时间+计算时间）

# 并发控制
临界区调度：无空等待，有空让进，择一而入，算法可行
Dekker
```
process P1
begin
	inside[1]:=true;
	while inside[2] do
		if turn=2 then begin
			inside[1]:=false;
			while turn=2 do begin end;
			inside[1]:=true;
		end
	临界区;
	turn = 2；
	inside[1]:=false;
end;
```
Peterson
```
process P1
begin
 inside[1] := true;
turn := 2;
while (inside[2] and turn = 2)
do begin end;
临界区；
 inside[1] := false;
end;
```

信号量
记录型：非负整数，P时减一，V时加一，小于等于0从队列中唤醒
整型：直到大于0才能使用

生产者与消费者同步问题
引用两个信号量，buf和product
生产者：P(buf) v(product)
消费者：p(product) v(buf)
既有同步又有互斥的话，互斥在后面进行
多类产品与多生产者消费者问题（如盘子中的苹果和橘子问题）

如果plate的容量不止一个，那么可以再设置一个mutex用来保证producer的生产过程是互斥的 即p(plate) p(mutex) produce v(mutex) v(product)
```
father{
p(plate)
produce an apple;
v(apple);}
daughter{
p(apple);
take an apple;
v(plate)
eat;}
```

# 存储管理
页表占用内存，在地址转换中多一次内存访问（相连存储器-快表）
反置页表，节约空间
页框：进程号，页面号（mov ax,5000）需要匹配进程号和页面号都相同才可以，所以可能会忽快忽慢


## 局部页面替换
二次机会是在替换的时候才更新队列

![输入图片说明](/imgs/2024-06-12/PL2YMUJuOsSEiP7N.png)
相当于在前一个时间间隔t中将访问位清0的页面，（每一次时钟中断都会将访问位清0）改进的CLOCK算法
![输入图片说明](/imgs/2024-06-12/pRIKktrMlATiZqPN.png)
每个时钟中断对每个页面的访问位+到自己的计数器上，再将访问位清0
淘汰计数器最小的页面
![输入图片说明](/imgs/2024-06-12/5Jw7jZaotbbwDd7d.png)
前一次结果乘权重+访问位
## 全局页面替换
![输入图片说明](/imgs/2024-06-12/wr287e9ZxjhWovpA.png)
不在工作集的页面淘汰
![输入图片说明](/imgs/2024-06-12/58rdlij7y07UNGAh.png)
操作系统没法实现，只能由硬件提供

![输入图片说明](/imgs/2024-06-12/pl7NxS59GN9KRJzZ.png)
浪费函数
![输入图片说明](/imgs/2024-06-12/kPXGrvfoqDXIUjg8.png)
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTg4MDcwMDU5LC0xMDIyMDE5MjE0LDU1ND
g2MDY0OSwtNjExNzc0NTE3LDIzNzA0MTk5MiwxMTE1MDM0MjE3
LC0xNzI2NTUxMTg3LDc2Njc2NTUwLDg0ODk4MTg0NCwxNTU4Nz
M0OTQxLC0xMjk5ODcwNDY5LDE5ODAyODMxMDMsLTEyMjYxMzA5
OTIsMTc3MDA0MTQ3LDg5NDQyMjgwOSwtNTE0NzI1NTE2LDU1OT
E3MjE2NSwtMTQxNTk2OTMxNywtNTU3OTEzNDMsNjE5NDQxNjAy
XX0=
-->