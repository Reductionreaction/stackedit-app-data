# 概述

[toc]

CPU工作模式不同，工作能力与指令集有关

全部指令与特权指令（in,out,mov），kelnel mode核心态模式，user mode时要排除特权指令

-   发生异常中断进程，例如在普通用户程序中出现特权指令，cpu状态会发生翻转，切换到k-mode，查询中断向量表(异常对应的处理代码)，处理错误

操作系统是程序，提供硬件与用户的媒介，提供环境，以便利有效的方式运行程

-   扩展机器-抽象与模拟 -> 将每个程序运行在一个虚拟机中，有自己的设备，储存器

-   资源管理-保护与复用 -> 时分，空分复用

终端设备：显示器+键盘

| cpu |  |
|--|--|
| io | ram |

jmp, mov, call访问地址的命令都有可能发生异常：地址越界 || 地址不在主存中(缺页)
**并发**的设计最初是为了不同的计算任务在同一个设备上运行(提高硬件资源的利用率), 同一个任务的分解虽然加快了任务的速度, 但是需要提供同步机制(任务执行的速度不同会发生错误)

程序的推进速度受到外围设备的影响，异步性在非并发进程中没有影响

**操作系统的主要特征**
- 并发性
	- 提高资源的利用率
- 共享性
	- 时分复用 $\rightarrow$ 互斥访问
	- 同时访问：磁盘，主存 $\rightarrow$ 空间复用
- 异步性
	- 任务执行时间, 推进速度不同, 中断的发生, 事件发生不可预测
	- 能处理随机发生的事件
- 虚拟性
	- 应用程序使用时在虚拟机上运行,$\rightarrow$ 将一个设备虚拟成多个
	- $0 \rightarrow2^{32}-1$ 或 $0\rightarrow2^{64}-1$ 位地址都可以使用, 将主存和磁盘的一部分虚拟成一个主存, $\rightarrow$将多个设备虚拟成一个
	- 假脱机: 一个io设备虚拟成多个
	
# os运行机制

**计算机引导过程**
bios(可以访问io设备, 检测硬件) $\rightarrow$ 读取磁盘驱动0号扇区(55 aa?) $\rightarrow$ 跳转到对应地址MBR(硬件厂商确定格式) $\rightarrow$(这里还有一步跳转到grub或者lilo) 加载kernel到主存(0号进程,填中断向量表) $\rightarrow$ init进程(1号进程), 读取配置文件, 启动服务
idle 0 : 填满cpu使用时间
**os是中断驱动的**
- io设备通知cpu(有int引脚或控制芯片(可以并联)$\rightarrow$接受io设备的电信号, 发生变化后读取中断寄存器 $\rightarrow$硬件提供机制,查中断向量表(一组地址,硬件定义长度),执行对应地址上的代码)  **现代可以直接通知os**
- 初始化os时会初始化一个定时器: 每隔一段时间产生一个中断
- 中断过程中还可以调度其他程序
- 应用程序中发生异常(内中断) vs 外围设备通知中断(外中断)
- ```syscal``` 引发中断 : 与外部中断类似 ``` mov jmp /0```
![os是中断驱动的](/imgs/2024-03-06/2MBzTgXTdiu7dkpU.png)

- 保护模式：cpu可以运行在两种状态中$\rightarrow$ 核心态与用户态，早期是实模式，不区分核心态与用户态
- CR0, CR1, CR2属于控制寄存器，可以切换工作状态
- 用户态需要接受输入输出需要通过中断呼唤操作系统
- ```i++ : mov xxxx zax, add zax, mov zax xxxx```
- in/out需要访问外设
- 主存保护机制: 分段, cpu提供寄存器,由操作系统定义应用的起始地址, jmp, mov, call等指令时进行检查, 如果发生溢出, 就产生异常, 唤起操作系统.  地址转换时一并完成
**用户代码的有限直接执行**
---- 用户态A
        ---核心态
              ---用户态B
---  timeline ---
- sp指向栈顶位置
- call: 将下一条指令压入栈中(sp-2, 十六位), 跳转到对应的地址中(把pc赋值为地址), 执行子程序, 遇到ret指令就将pc赋值为sp
![输入图片说明](/imgs/2024-03-13/G1etVygmQsCwAubx.png)
少了中断处理程序, 和应用异常
**中断属于硬件机制, 保存现场信息 , cpu翻转到核心态, 查询中断向量表, os进行运行处理**
- 读入操作: 用out不断读取状态寄存器判断是否空闲, 发送读取命令, 用out对port进行写控制寄存器操作, 继续读状态寄存器, 写入数据寄存器直到free, 用In指令读到cpu中, 再用mov写到主存 $\rightarrow$ 



<!--stackedit_data:
eyJoaXN0b3J5IjpbMTkzODEwMjM4MSwxNTAyODg3OTUzLDEwOD
k5NDkzNDcsLTE0ODUxMTk2OTcsLTcxNDM2NTAzNCwtMTUxNjEz
MTY0OSwxNzIxNDE4NzEyLDYwODgyMTIxOSwtNjU0MjY2MDUyLC
03MzI3NDUzMTAsMTc4MjkxNjAyNSwtMTA3MjY0OTkyMiwtMTIw
ODU1NjEyMSwxNzIyMTY3NTgsLTE3MjUxMDI2MzAsLTE3MjUxMD
I2MzAsODU2OTM5MzU4LDEyMDMwMTg5NTgsMTUzMDc0NzY1MSwt
NzIyODI4Njg4XX0=
-->